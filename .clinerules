# 買いたいものリストアプリ - 開発ガイドライン (.clinerulesファイル)

## はじめに
このドキュメントは「買いたいものリスト」アプリを開発する際のガイドラインをまとめたものです。
このガイドラインに従って、開発作業を進めてください。

## 開発モードについて
以下の4つのモードを状況に応じて自動的に切り替えながら開発を行ってください。

| モード | 役割 | 自動切替のタイミング |
|--------|------|------------|
| PM | 要件定義・計画作成 | 新機能の検討時、段階的実装ロードマップの詳細化が必要な時 |
| Architect | 設計・技術選定 | DBスキーマ設計、API設計、技術スタック選定時 |
| Code | 実装・テスト | モデル実装、ルート実装、バリデーション実装時 |
| PMO | 品質管理・確認 | 機能完了時、コア機能からの段階的移行判断時 |

あなたは作業の内容や流れに応じて最適なモードを自動的に選択し、段階的な実装ロードマップに沿って効率的に作業を進めてください。

## 基本ルール
- 段階的実装アプローチ:
   - 第1段階のコア機能(MVP)から始め、順次拡張機能を追加する
   - 各段階が完了したことを確認してから次の段階に進む
   - 機能のオーバーエンジニアリングを避ける

- データ中心の設計思想:
   - ユーザーが「買いたいもの」を適切に管理できることを最優先にする
   - 優先度設定と履歴管理を重視する
   - 購入記録と振り返り機能の連携を意識する

- 既存コードの尊重:
   - Remix+Supabaseのパターンに沿った実装を行う
   - API設計ドキュメントで定義された関数名・パスを尊重する
   - 一貫したデータ構造と命名規則を維持する

- 連続で修正に失敗した場合:
   - 2回以上連続でテストを失敗した時は、現在の状況を整理して報告
   - 同じアプローチを繰り返すのではなく、代替案を提示する

## セキュリティ
### 機密ファイル
以下を読み取ったり変更したりすることは絶対に避けてください。
- `.env` ファイル
- Supabase関連の認証情報
- Auth0関連の認証情報
- JWT関連の鍵やシークレット
- APIキー、トークン、認証情報を含むファイル全般

何か機密ファイルの編集が必要になった場合は、指示を仰いでください。

また、以下のセキュリティガイドラインに従って作業を行ってください。
- 機密ファイルを絶対にコミットしない
- 環境変数（dotenv）を活用したシークレット管理
- ユーザーデータのプライバシーを常に考慮する
- JSONWebTokenの適切な取り扱い

## 作業プロセス
以下のプロセスに従って、作業を進めます。

1. 要件理解（PMモード）
   - ロードマップの段階確認
   - 実装する機能の詳細化・優先順位付け
   - 必要に応じてユーザーストーリーの詳細化

2. 設計（Architectモード）
   - Supabaseテーブル設計の検証
   - API関数の設計レビュー
   - データフローの設計

3. 実装（Codeモード）
   - モデル層の実装（`/app/models/`）
   - ルートの実装（`/app/routes/`）

4. 品質確認（PMOモード）
   - 要件充足の確認
   - 次の段階への移行判断
   - 動作確認とコードレビュー

AIはこれらのステップを自動的に判断して進め、1回のリクエストでも可能な限り完結した成果物を提供します。

## 技術スタック
プロジェクトで定義された以下の技術スタックに従って開発を行います。

### フロントエンド
- 言語: TypeScript
- フレームワーク: Remix v2 (Vite構成)
- UI: TailwindCSS + DaisyUI
- 状態管理: Remix Loader/Action
- フォームバリデーション: Zod

### バックエンド
- 言語: TypeScript (Node.js v20+)
- API: RemixのServer Side関数
- データベース: PostgreSQL (Supabase)
- 認証: Remix Auth + Auth0
- スクレイピング: Cheerio

### 開発ツール
- リンター: Biome
- フォーマッター: Biome
- Git Hooks: Lefthook
- ビルドツール: Vite

## データベース設計ガイドライン
- テーブル構造は仕様書のスキーマに基づく
- 以下の3つの主要テーブルを適切に設計・実装する:
  - `users` テーブル
  - `wish_items` テーブル
  - `priority_history` テーブル
- ENUMタイプの適切な使用（優先度、ステータス）
- 適切な外部キー制約の設定
- Supabase環境での最適なクエリ設計

## API設計ガイドライン
- API関数は仕様書で定義された名前・パスに従う
- コア機能（MVP）の8つのAPI関数を優先実装:
  1. `createWishItem`
  2. `getWishItems`
  3. `getWishItem`
  4. `updateWishItem`
  5. `deleteWishItem`
  6. `updateItemPriority`
  7. `markItemStatus`
  8. `scrapeProductInfo` (Cheerioを使用)
- 拡張機能のAPIは第2段階以降で実装

## コーディングガイドライン
### 一般原則
- Remix v2 + Viteのパターンに沿った実装
- モデル層とルート層の適切な分離
- エラーハンドリングの適切な実装
- コメントは必要な箇所にのみ付ける

### フォルダ構造
```
/app
  /models          # データモデル層（Supabase連携）
  /routes          # Remixルート
  /utils           # ユーティリティ関数
  /components      # 再利用可能なコンポーネント
  /styles          # TailwindCSS関連
  /auth            # 認証関連（Remix Auth + Auth0）
```

### コード品質
- Biomeを使用したlintとformat
- TypeScriptの型チェック徹底
- TailwindCSSとDaisyUIによる一貫したUIデザイン

### コミットメッセージのガイドライン
簡潔かつ明確なコミットメッセージを記述することで、変更履歴を追いやすくします。

### コミットプレフィックス
- feat: 新機能追加（例: `feat: 買いたいものの追加機能実装`）
- fix: バグ修正（例: `fix: 優先度更新時のトランザクション処理修正`）
- docs: ドキュメント更新（例: `docs: APIドキュメント更新`）
- style: スタイル調整（例: `style: アイテムリスト表示の改善`）
- refactor: リファクタリング（例: `refactor: wish-item.server.tsのリファクタリング`）
- test: テスト追加・修正（例: `test: 優先度履歴のテスト追加`）
- chore: 雑務的な変更（例: `chore: パッケージ更新`）

### コミットの注意事項
- 1つのコミットでは機能単位の変更のみを含める
- コア機能と拡張機能の変更は分けてコミットする
- コミットメッセージは日本語で記述可能
- Lefthookによるコミット前のコード品質チェックを通過させる
- 自動テストはないが、動作確認を行ってからコミットする
- **重要**: コミットを実行する前に必ず開発者の明示的な許可を得ること
- git add や git commit コマンドは自動実行せず、開発者の指示を待つこと

## 段階的実装のベストプラクティス
- 第1段階（MVP）の完成を最優先する
- 各段階で必要最小限の実装に留める
- 拡張しやすい設計を心がける
- 優先度変更履歴など特徴的な機能の品質を重視する
- ユーザーの「買いたいもの」管理体験を常に意識する
- 直接的な動作確認を通じた品質保証

## 技術固有のガイドライン

### Supabase連携
- Supabaseクライアントの適切な初期化
- トランザクションを活用した優先度履歴の記録
- データ取得クエリの最適化

### 認証関連
- Remix Auth + Auth0の適切な設定
- JWTを使用したセッション管理
- ログイン・ログアウトフローの適切な実装

### UI実装
- TailwindCSSとDaisyUIを活用した一貫したデザイン
- レスポンシブデザインの徹底
- アクセシビリティへの配慮